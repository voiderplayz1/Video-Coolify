<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>VFXAI â€” Make My Video Cool</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@400;500;600;700&display=swap');

:root {
  --bg: #080c10;
  --surface: #0d1117;
  --surface2: #111823;
  --border: #1c2a3a;
  --border2: #243040;
  --accent: #e8f4ff;
  --accent-glow: rgba(180,220,255,0.15);
  --accent-dim: rgba(200,230,255,0.5);
  --cyan: #4fc3f7;
  --cyan-glow: rgba(79,195,247,0.2);
  --green: #69f0ae;
  --red: #ff6b6b;
  --text: #c8d8e8;
  --muted: #4a6070;
  --mono: 'Share Tech Mono', monospace;
  --sans: 'Rajdhani', sans-serif;
  --r: 8px;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { height: 100%; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--sans);
  min-height: 100%;
  line-height: 1.5;
  overflow-x: hidden;
}

/* â•â• SCANLINE BG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
body::before {
  content: '';
  position: fixed; inset: 0; pointer-events: none; z-index: 0;
  background:
    repeating-linear-gradient(0deg, transparent 0px, transparent 3px, rgba(0,0,0,0.08) 3px, rgba(0,0,0,0.08) 4px),
    radial-gradient(ellipse at 50% 0%, rgba(30,60,100,0.25) 0%, transparent 65%);
}

/* â•â• DEVICE POPUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#deviceOverlay {
  position: fixed; inset: 0; z-index: 9999;
  background: rgba(4, 8, 14, 0.97);
  display: flex; align-items: center; justify-content: center;
  padding: 20px;
  backdrop-filter: blur(4px);
}
#deviceOverlay.hidden { display: none; }

.device-popup {
  background: var(--surface);
  border: 1px solid var(--border2);
  border-radius: 16px;
  padding: 48px 40px 40px;
  max-width: 440px; width: 100%;
  text-align: center;
  position: relative;
  box-shadow: 0 0 60px rgba(79,195,247,0.06), 0 24px 48px rgba(0,0,0,0.6);
  animation: popSlideIn 0.45s cubic-bezier(0.22, 1, 0.36, 1) forwards;
}
@keyframes popSlideIn {
  from { opacity: 0; transform: scale(0.88) translateY(24px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}

.device-popup .corner {
  position: absolute; width: 14px; height: 14px;
  border-color: var(--cyan); border-style: solid; opacity: 0.6;
}
.device-popup .corner.tl { top: 12px; left: 12px; border-width: 2px 0 0 2px; }
.device-popup .corner.tr { top: 12px; right: 12px; border-width: 2px 2px 0 0; }
.device-popup .corner.bl { bottom: 12px; left: 12px; border-width: 0 0 2px 2px; }
.device-popup .corner.br { bottom: 12px; right: 12px; border-width: 0 2px 2px 0; }

.device-popup .eye {
  font-family: var(--mono);
  font-size: 10px;
  letter-spacing: 0.3em;
  color: var(--cyan);
  text-transform: uppercase;
  margin-bottom: 18px;
  opacity: 0.8;
}
.device-popup h2 {
  font-size: 15px;
  font-weight: 600;
  color: var(--accent);
  line-height: 1.55;
  margin-bottom: 6px;
  letter-spacing: 0.01em;
}
.device-popup .sub {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--muted);
  margin-bottom: 36px;
  letter-spacing: 0.05em;
}

.device-btn {
  display: flex; align-items: center; gap: 18px;
  width: 100%; padding: 18px 22px;
  background: var(--bg);
  border: 1px solid var(--border2);
  border-radius: var(--r);
  cursor: pointer; margin-bottom: 12px;
  transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
  text-align: left; color: var(--text);
  font-family: var(--sans);
}
.device-btn:hover {
  border-color: var(--cyan);
  background: rgba(79,195,247,0.04);
  box-shadow: 0 0 20px rgba(79,195,247,0.1);
}
.device-btn .icon { font-size: 30px; flex-shrink: 0; }
.device-btn .lbl  { font-size: 17px; font-weight: 700; letter-spacing: 0.02em; color: var(--accent); }
.device-btn .desc { font-size: 12px; color: var(--muted); font-family: var(--mono); margin-top: 3px; }

/* â•â• HEADER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
header {
  position: relative; z-index: 10;
  display: flex; align-items: center; justify-content: space-between;
  padding: 20px 40px;
  border-bottom: 1px solid var(--border);
}
.logo {
  display: flex; align-items: center; gap: 12px;
  font-family: var(--mono); font-size: 15px;
  color: var(--accent); letter-spacing: 0.08em;
}
.logo-pulse {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--cyan);
  box-shadow: 0 0 8px var(--cyan);
  animation: blink 1.8s ease-in-out infinite;
}
@keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
.header-tag {
  font-family: var(--mono); font-size: 10px;
  color: var(--muted); letter-spacing: 0.15em;
}

/* â•â• MAIN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.main {
  position: relative; z-index: 1;
  max-width: 780px; margin: 0 auto;
  padding: 56px 24px 80px;
}

/* â•â• HERO â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.hero { margin-bottom: 52px; }
.hero-label {
  display: inline-flex; align-items: center; gap: 8px;
  font-family: var(--mono); font-size: 10px;
  color: var(--cyan); letter-spacing: 0.2em; text-transform: uppercase;
  margin-bottom: 18px; padding: 5px 12px;
  border: 1px solid rgba(79,195,247,0.25);
  border-radius: 100px; background: rgba(79,195,247,0.05);
}
.hero-label span { width: 5px; height: 5px; border-radius: 50%; background: var(--cyan); animation: blink 1.2s infinite; }
.hero h1 {
  font-size: clamp(36px, 7vw, 62px);
  font-weight: 700; line-height: 1.05;
  letter-spacing: -0.02em;
  color: var(--accent);
  margin-bottom: 16px;
}
.hero h1 em { color: var(--cyan); font-style: normal; }
.hero p {
  font-size: 15px; color: var(--muted);
  max-width: 500px; line-height: 1.7;
}

/* â•â• STEP LABELS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.step-label {
  font-family: var(--mono); font-size: 10px;
  color: var(--cyan); letter-spacing: 0.2em; text-transform: uppercase;
  margin-bottom: 10px; opacity: 0.7;
}

/* â•â• UPLOAD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.upload-area {
  position: relative; margin-bottom: 20px;
  border: 1.5px dashed var(--border2);
  border-radius: 12px;
  padding: 52px 32px;
  text-align: center;
  cursor: pointer;
  background: var(--surface);
  transition: border-color 0.25s, background 0.25s, box-shadow 0.25s;
  overflow: hidden;
}
.upload-area::after {
  content: '';
  position: absolute; inset: 0; pointer-events: none;
  background: radial-gradient(ellipse at 50% 0%, rgba(79,195,247,0.05) 0%, transparent 70%);
  opacity: 0; transition: opacity 0.3s;
}
.upload-area:hover, .upload-area.drag-over {
  border-color: var(--cyan);
  background: rgba(79,195,247,0.03);
  box-shadow: 0 0 30px rgba(79,195,247,0.08);
}
.upload-area:hover::after, .upload-area.drag-over::after { opacity: 1; }
.upload-area.has-file { border-style: solid; border-color: rgba(79,195,247,0.4); }
.upload-area input[type=file] { position: absolute; inset: 0; opacity: 0; cursor: pointer; }

.upload-icon { font-size: 44px; margin-bottom: 14px; }
.upload-area h3 { font-size: 18px; font-weight: 700; color: var(--accent); margin-bottom: 6px; letter-spacing: 0.01em; }
.upload-area p  { font-size: 13px; color: var(--muted); font-family: var(--mono); }
.file-chip {
  display: none; margin-top: 14px;
  font-family: var(--mono); font-size: 12px;
  color: var(--cyan); background: rgba(79,195,247,0.1);
  border: 1px solid rgba(79,195,247,0.2);
  padding: 6px 14px; border-radius: 100px;
  display: inline-block; display: none;
}

/* â•â• OPTIONS CARD â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 28px;
  margin-bottom: 20px;
}
.card-title {
  font-size: 14px; font-weight: 700;
  color: var(--accent); letter-spacing: 0.05em;
  margin-bottom: 22px; text-transform: uppercase;
  font-family: var(--mono);
}

.toggle-row {
  display: flex; align-items: flex-start;
  justify-content: space-between; gap: 20px;
}
.toggle-info .tlabel { font-size: 15px; font-weight: 700; color: var(--accent); }
.toggle-info .tdesc  { font-size: 12px; color: var(--muted); margin-top: 4px; font-family: var(--mono); line-height: 1.6; max-width: 380px; }

.toggle-switch {
  flex-shrink: 0; width: 46px; height: 24px;
  background: var(--border2); border-radius: 100px;
  border: none; cursor: pointer; position: relative;
  transition: background 0.25s;
  outline: none;
}
.toggle-switch::after {
  content: ''; position: absolute;
  left: 3px; top: 3px;
  width: 18px; height: 18px;
  border-radius: 50%; background: var(--muted);
  transition: transform 0.25s, background 0.25s;
}
.toggle-switch.active { background: rgba(79,195,247,0.25); }
.toggle-switch.active::after { transform: translateX(22px); background: var(--cyan); }

.audio-extra {
  display: none; margin-top: 20px; padding-top: 20px;
  border-top: 1px solid var(--border);
}
.audio-extra.show { display: block; }

.audio-pick {
  position: relative;
  display: flex; align-items: center; gap: 14px;
  padding: 14px 18px;
  background: var(--bg);
  border: 1px dashed var(--border2);
  border-radius: var(--r);
  cursor: pointer; width: 100%;
  transition: border-color 0.2s;
  font-family: var(--sans);
  color: var(--text);
}
.audio-pick:hover { border-color: var(--cyan); }
.audio-pick input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
.audio-pick .ap-icon { font-size: 22px; }
.audio-pick .ap-label { font-size: 14px; font-weight: 700; color: var(--accent); }
.audio-pick .ap-sub   { font-size: 11px; color: var(--muted); font-family: var(--mono); margin-top: 2px; }
#audioName {
  display: none; margin-top: 10px;
  font-family: var(--mono); font-size: 11px;
  color: var(--cyan);
}

/* â•â• CONVERT BUTTON â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#convertBtn {
  width: 100%; padding: 19px;
  background: var(--surface2);
  border: 1.5px solid var(--border2);
  border-radius: var(--r);
  color: var(--accent);
  font-family: var(--sans); font-size: 17px; font-weight: 700;
  letter-spacing: 0.06em; text-transform: uppercase;
  cursor: pointer; position: relative; overflow: hidden;
  transition: border-color 0.25s, box-shadow 0.25s, background 0.25s;
  margin-bottom: 28px;
}
#convertBtn::before {
  content: '';
  position: absolute; inset: 0;
  background: linear-gradient(90deg, transparent, rgba(79,195,247,0.08), transparent);
  transform: translateX(-100%);
  transition: transform 0.7s;
}
#convertBtn:not(:disabled):hover::before { transform: translateX(100%); }
#convertBtn:not(:disabled):hover {
  border-color: var(--cyan);
  box-shadow: 0 0 30px rgba(79,195,247,0.15), 0 4px 20px rgba(0,0,0,0.4);
  background: rgba(79,195,247,0.05);
}
#convertBtn:disabled {
  opacity: 0.3; cursor: not-allowed;
}

/* â•â• PROGRESS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#progressSection { display: none; margin-bottom: 28px; }
#progressSection.show { display: block; }

.prog-header {
  display: flex; justify-content: space-between; align-items: baseline;
  margin-bottom: 8px;
}
.prog-label { font-family: var(--mono); font-size: 11px; color: var(--cyan); }
.prog-pct   { font-family: var(--mono); font-size: 13px; color: var(--accent); }
.prog-track {
  height: 2px; background: var(--border);
  border-radius: 100px; overflow: hidden; margin-bottom: 16px;
}
.prog-fill {
  height: 100%; width: 0%;
  background: var(--cyan);
  border-radius: 100px;
  box-shadow: 0 0 8px var(--cyan);
  transition: width 0.4s ease;
}
.prog-steps { display: flex; gap: 8px; flex-wrap: wrap; }
.pchip {
  font-family: var(--mono); font-size: 10px;
  padding: 3px 10px; border-radius: 100px;
  border: 1px solid var(--border2); color: var(--muted);
  transition: all 0.3s; letter-spacing: 0.05em;
}
.pchip.active { border-color: var(--cyan); color: var(--cyan); background: rgba(79,195,247,0.1); }
.pchip.done   { border-color: transparent; color: var(--border2); }

/* â•â• RESULT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#resultSection { display: none; }
#resultSection.show { display: block; }
.result-card {
  background: #000;
  border: 1px solid var(--border2);
  border-radius: 12px; overflow: hidden;
  box-shadow: 0 0 40px rgba(79,195,247,0.08);
}
.result-card video {
  width: 100%; display: block;
  max-height: 480px; object-fit: contain;
  background: #000;
}
.result-actions {
  display: flex; gap: 12px;
  padding: 20px 24px;
  border-top: 1px solid var(--border);
  flex-wrap: wrap;
}
.btn-primary {
  flex: 1; min-width: 160px;
  padding: 13px 20px;
  background: var(--cyan); color: #050c14;
  border: none; border-radius: var(--r);
  font-family: var(--sans); font-size: 14px; font-weight: 700;
  letter-spacing: 0.06em; text-transform: uppercase;
  cursor: pointer; transition: opacity 0.2s, transform 0.2s;
}
.btn-primary:hover { opacity: 0.88; transform: translateY(-1px); }
.btn-secondary {
  flex: 1; min-width: 160px;
  padding: 13px 20px;
  background: transparent; color: var(--muted);
  border: 1px solid var(--border2); border-radius: var(--r);
  font-family: var(--sans); font-size: 14px; font-weight: 600;
  letter-spacing: 0.04em; text-transform: uppercase;
  cursor: pointer; transition: border-color 0.2s, color 0.2s;
}
.btn-secondary:hover { border-color: var(--accent-dim); color: var(--text); }

/* â•â• DOWNLOAD POPUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#dlOverlay {
  position: fixed; inset: 0; z-index: 8888;
  background: rgba(4,8,14,0.85);
  backdrop-filter: blur(10px);
  display: none; align-items: center; justify-content: center;
  padding: 20px;
}
#dlOverlay.open { display: flex; }
.dl-popup {
  background: var(--surface);
  border: 1px solid var(--border2);
  border-radius: 16px;
  padding: 36px 32px 28px;
  max-width: 400px; width: 100%;
  animation: popSlideIn 0.3s cubic-bezier(0.22,1,0.36,1);
  position: relative;
}
.dl-popup h3 {
  font-size: 20px; font-weight: 700;
  color: var(--accent); margin-bottom: 6px;
  letter-spacing: 0.02em;
}
.dl-popup .dl-sub {
  font-family: var(--mono); font-size: 11px;
  color: var(--muted); margin-bottom: 26px;
}
.dl-opt {
  display: flex; align-items: center; gap: 16px;
  width: 100%; padding: 16px 18px;
  background: var(--bg);
  border: 1px solid var(--border2);
  border-radius: var(--r); cursor: pointer;
  margin-bottom: 10px;
  transition: border-color 0.2s, background 0.2s;
  font-family: var(--sans); color: var(--text);
}
.dl-opt:hover { border-color: var(--cyan); background: rgba(79,195,247,0.04); }
.dl-opt .fmt {
  font-family: var(--mono); font-size: 16px; font-weight: 700;
  color: var(--cyan); width: 54px; flex-shrink: 0;
}
.dl-opt .fo-label { font-size: 14px; font-weight: 700; color: var(--accent); }
.dl-opt .fo-desc  { font-size: 11px; color: var(--muted); font-family: var(--mono); margin-top: 3px; }
.dl-cancel {
  width: 100%; padding: 11px;
  background: transparent; border: 1px solid var(--border);
  border-radius: var(--r); color: var(--muted);
  font-family: var(--sans); font-size: 13px; cursor: pointer;
  margin-top: 4px; transition: border-color 0.2s;
}
.dl-cancel:hover { border-color: var(--muted); }

/* â•â• MOBILE OVERRIDES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
body.mobile-mode header { padding: 16px 20px; }
body.mobile-mode .main { padding: 36px 16px 60px; }
body.mobile-mode .hero h1 { font-size: 34px; }
body.mobile-mode .upload-area { padding: 40px 20px; }
body.mobile-mode .card { padding: 22px 18px; }
body.mobile-mode .result-actions { flex-direction: column; }
body.mobile-mode .btn-primary,
body.mobile-mode .btn-secondary { width: 100%; flex: none; }
body.mobile-mode .dl-popup { padding: 28px 20px 22px; }
body.mobile-mode header { padding: 14px 16px; }
body.mobile-mode .device-popup { padding: 36px 20px 28px; }

/* â•â• NOTICE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.notice {
  display: flex; gap: 10px; align-items: flex-start;
  padding: 12px 16px;
  background: rgba(105,240,174,0.04);
  border: 1px solid rgba(105,240,174,0.12);
  border-radius: var(--r); margin-bottom: 20px;
  font-size: 12px; color: var(--muted); font-family: var(--mono);
  line-height: 1.6;
}
.notice .ni { color: var(--green); flex-shrink: 0; }
</style>
</head>
<body>

<!-- â•â• DEVICE SELECTION POPUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="deviceOverlay">
  <div class="device-popup">
    <div class="corner tl"></div><div class="corner tr"></div>
    <div class="corner bl"></div><div class="corner br"></div>
    <div class="eye">// SYSTEM INIT</div>
    <h2>hey! i just need you to answer this real quick,<br>this WILL CHANGE how you view the site!</h2>
    <div class="sub">select your device to continue_</div>
    <button class="device-btn" onclick="chooseDevice('pc')">
      <span class="icon">ğŸ–¥ï¸</span>
      <div>
        <div class="lbl">PC / Laptop</div>
        <div class="desc">full desktop experience</div>
      </div>
    </button>
    <button class="device-btn" onclick="chooseDevice('mobile')">
      <span class="icon">ğŸ“±</span>
      <div>
        <div class="lbl">Mobile Device</div>
        <div class="desc">touch-optimized layout</div>
      </div>
    </button>
  </div>
</div>

<!-- â•â• DOWNLOAD POPUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="dlOverlay" onclick="if(event.target===this)closeDl()">
  <div class="dl-popup">
    <h3>Choose Format</h3>
    <div class="dl-sub">// select output format to download_</div>
    <button class="dl-opt" onclick="doDownload('mp4')">
      <span class="fmt">.MP4</span>
      <div>
        <div class="fo-label">MP4 â€” H.264</div>
        <div class="fo-desc">universal Â· works on all devices &amp; platforms</div>
      </div>
    </button>
    <button class="dl-opt" onclick="doDownload('webm')">
      <span class="fmt">.WEBM</span>
      <div>
        <div class="fo-label">WebM â€” VP8</div>
        <div class="fo-desc">web-optimized Â· smaller file size</div>
      </div>
    </button>
    <button class="dl-opt" onclick="doDownload('mov')">
      <span class="fmt">.MOV</span>
      <div>
        <div class="fo-label">MOV â€” QuickTime</div>
        <div class="fo-desc">apple devices Â· best for video editing</div>
      </div>
    </button>
    <button class="dl-cancel" onclick="closeDl()">Cancel</button>
  </div>
</div>

<!-- â•â• HEADER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<header>
  <div class="logo">
    <div class="logo-pulse"></div>
    VFX<span style="color:var(--cyan)">AI</span>
  </div>
  <div class="header-tag">NODE GRAPH OVERLAY v1.0</div>
</header>

<!-- â•â• MAIN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<main class="main">

  <div class="hero">
    <div class="hero-label"><span></span> AI MOTION ANALYSIS</div>
    <h1>Make Your<br>Video <em>Cool</em></h1>
    <p>Upload any video and watch AI overlay a live node-graph tracking network â€” connecting motion points with glowing lines, just like the videos you've seen.</p>
  </div>

  <!-- STEP 1: Upload -->
  <div class="step-label">// 01 &nbsp; UPLOAD VIDEO</div>
  <div class="upload-area" id="uploadArea">
    <input type="file" id="videoInput" accept="video/mp4,video/quicktime,.mov,.mp4" />
    <div class="upload-icon">ğŸ“‚</div>
    <h3>Drop your video here</h3>
    <p>MP4 or MOV &nbsp;Â·&nbsp; any resolution</p>
    <div class="file-chip" id="fileChip"></div>
  </div>

  <!-- STEP 2: Audio Option -->
  <div class="step-label">// 02 &nbsp; AUDIO (OPTIONAL)</div>
  <div class="card" style="margin-bottom:20px;">
    <div class="card-title">// AUDIO SETTINGS</div>
    <div class="toggle-row">
      <div class="toggle-info">
        <div class="tlabel">Replace Audio Track</div>
        <div class="tdesc">Remove the original audio and swap it with your own file. Your track will be cut to match the video length.</div>
      </div>
      <button class="toggle-switch" id="audioToggle" onclick="toggleAudio()"></button>
    </div>
    <div class="audio-extra" id="audioExtra">
      <button class="audio-pick">
        <input type="file" id="audioInput" accept="audio/*" onchange="onAudioPick()" />
        <span class="ap-icon">ğŸµ</span>
        <div>
          <div class="ap-label">Upload Audio Track</div>
          <div class="ap-sub">MP3 Â· WAV Â· AAC Â· OGG Â· any audio format</div>
        </div>
      </button>
      <div id="audioName"></div>
    </div>
  </div>

  <!-- STEP 3: Convert -->
  <div class="step-label">// 03 &nbsp; PROCESS</div>
  <div class="notice">
    <span class="ni">â„¹</span>
    <span>All processing happens locally in your browser â€” nothing is uploaded to any server. Large videos may take a few minutes. Works best on videos under 3 minutes.</span>
  </div>
  <button id="convertBtn" disabled onclick="startConvert()">
    â¬¡ &nbsp; Make My Video Cool
  </button>

  <!-- PROGRESS -->
  <div id="progressSection">
    <div class="prog-header">
      <span class="prog-label" id="progLabel">initializing...</span>
      <span class="prog-pct" id="progPct">0%</span>
    </div>
    <div class="prog-track"><div class="prog-fill" id="progFill"></div></div>
    <div class="prog-steps">
      <div class="pchip" id="c1">DECODE</div>
      <div class="pchip" id="c2">ANALYZE</div>
      <div class="pchip" id="c3">OVERLAY</div>
      <div class="pchip" id="c4">ENCODE</div>
    </div>
  </div>

  <!-- RESULT -->
  <div id="resultSection">
    <div class="step-label" style="margin-bottom:14px;">// DONE â€” PREVIEW &amp; DOWNLOAD</div>
    <div class="result-card">
      <video id="resultVideo" controls playsinline></video>
    </div>
    <div class="result-actions">
      <button class="btn-primary" onclick="openDl()">â¬‡ &nbsp; Download</button>
      <button class="btn-secondary" onclick="resetAll()">â†© &nbsp; Convert Another</button>
    </div>
  </div>

</main>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DEVICE SETUP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function chooseDevice(type) {
  document.getElementById('deviceOverlay').classList.add('hidden');
  if (type === 'mobile') document.body.classList.add('mobile-mode');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FILE HANDLING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let videoFile = null;
let audioFile = null;
let resultBlob = null;
let audioOn = false;

const videoInput  = document.getElementById('videoInput');
const uploadArea  = document.getElementById('uploadArea');
const fileChip    = document.getElementById('fileChip');
const convertBtn  = document.getElementById('convertBtn');

uploadArea.addEventListener('dragover',  e => { e.preventDefault(); uploadArea.classList.add('drag-over'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('drag-over'));
uploadArea.addEventListener('drop', e => {
  e.preventDefault(); uploadArea.classList.remove('drag-over');
  const f = e.dataTransfer.files[0];
  if (f) setVideoFile(f);
});
videoInput.addEventListener('change', () => { if (videoInput.files[0]) setVideoFile(videoInput.files[0]); });

function setVideoFile(f) {
  videoFile = f;
  uploadArea.classList.add('has-file');
  fileChip.style.display = 'inline-block';
  fileChip.textContent = 'âœ“ ' + f.name;
  convertBtn.disabled = false;
}

function toggleAudio() {
  audioOn = !audioOn;
  document.getElementById('audioToggle').classList.toggle('active', audioOn);
  document.getElementById('audioExtra').classList.toggle('show', audioOn);
}
function onAudioPick() {
  const f = document.getElementById('audioInput').files[0];
  if (!f) return;
  audioFile = f;
  const el = document.getElementById('audioName');
  el.style.display = 'block';
  el.textContent = 'âœ“ ' + f.name;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PROGRESS HELPERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function setProgress(pct, label, step) {
  document.getElementById('progFill').style.width = pct + '%';
  document.getElementById('progPct').textContent = Math.round(pct) + '%';
  document.getElementById('progLabel').textContent = label;
  ['c1','c2','c3','c4'].forEach((id, i) => {
    const el = document.getElementById(id);
    el.className = 'pchip' + (i < step ? ' done' : i === step ? ' active' : '');
  });
}
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAIN CONVERT ENTRY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function startConvert() {
  if (!videoFile) return;
  convertBtn.disabled = true;
  document.getElementById('resultSection').classList.remove('show');
  document.getElementById('progressSection').classList.add('show');
  setProgress(2, 'loading video...', 0);

  try {
    resultBlob = await processVideo(videoFile, audioOn ? audioFile : null);
    setProgress(100, 'complete!', 4);
    await sleep(400);
    showResult(resultBlob);
  } catch(err) {
    console.error(err);
    setProgress(0, 'error: ' + err.message, -1);
    convertBtn.disabled = false;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CORE VIDEO PROCESSING â€” NODE GRAPH OVERLAY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function processVideo(srcFile, replaceAudioFile) {
  /* â€” Load the source video â€” */
  const srcURL = URL.createObjectURL(srcFile);
  const vid = document.createElement('video');
  vid.src = srcURL; vid.muted = true; vid.preload = 'auto';
  await new Promise((res, rej) => {
    vid.onloadedmetadata = res;
    vid.onerror = rej;
    vid.load();
  });
  await seekTo(vid, 0);

  const W = vid.videoWidth;
  const H = vid.videoHeight;
  const FPS = 30;
  const duration = vid.duration;
  const totalFrames = Math.ceil(duration * FPS);

  /* â€” Canvas setup â€” */
  const canvas = document.createElement('canvas');
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  /* â€” Off-screen for pixel reading â€” */
  const offCanvas = document.createElement('canvas');
  offCanvas.width = W; offCanvas.height = H;
  const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });

  /* â€” MediaRecorder setup â€” */
  const mimeType = getSupportedMime();
  const stream = canvas.captureStream(FPS);
  const chunks = [];
  const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 8_000_000 });
  recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
  recorder.start(200);

  /* â€” Node graph state â€” */
  let nodes = [];          // { x, y, hexVal, life, vx, vy }
  let prevLuma = null;
  const MIN_DIST = 60;     // minimum distance between nodes

  setProgress(8, 'decoding frames...', 0);

  /* â”€â”€ FRAME LOOP â”€â”€ */
  for (let fi = 0; fi < totalFrames; fi++) {
    const t = fi / FPS;
    vid.currentTime = t;
    await seekTo(vid, t);

    /* Draw source frame */
    ctx.drawImage(vid, 0, 0, W, H);

    /* Get luma for motion analysis */
    offCtx.drawImage(vid, 0, 0, W, H);
    const imgData = offCtx.getImageData(0, 0, W, H);
    const luma = getLuma(imgData, W, H);

    if (prevLuma) {
      /* â”€â”€ DETECT HIGH-MOTION AREAS â”€â”€ */
      const hotspots = findHotspots(luma, prevLuma, W, H);

      /* â”€â”€ SPAWN NEW NODES AT HOTSPOTS â”€â”€ */
      for (const hs of hotspots) {
        /* Only spawn if not too close to existing nodes */
        const tooClose = nodes.some(n => dist(n.x, n.y, hs.x, hs.y) < MIN_DIST);
        if (!tooClose) {
          nodes.push({
            x: hs.x, y: hs.y,
            hexVal: '0x' + Math.floor(Math.random() * 256).toString(16).toUpperCase().padStart(2, '0'),
            life: 1.0,
            targetX: hs.x + (Math.random() - 0.5) * 10,
            targetY: hs.y + (Math.random() - 0.5) * 10,
          });
        }
        /* Keep population bounded */
        if (nodes.length > 12) break;
      }

      /* â”€â”€ AGE NODES â”€â”€ */
      for (const n of nodes) {
        n.life -= 0.018;
        /* Drift toward target */
        n.x += (n.targetX - n.x) * 0.05;
        n.y += (n.targetY - n.y) * 0.05;
        /* Re-check against current motion: boost life if still in hot area */
        const li = (Math.floor(n.y) * W + Math.floor(n.x));
        if (li >= 0 && li < luma.length && prevLuma[li] !== undefined) {
          const d = Math.abs(luma[li] - prevLuma[li]);
          if (d > 25) n.life = Math.min(1.0, n.life + 0.04);
        }
      }
      nodes = nodes.filter(n => n.life > 0);

      /* â”€â”€ DRAW OVERLAY â”€â”€ */
      drawNodeGraph(ctx, nodes, W, H);
    }

    prevLuma = luma;

    /* Progress */
    const pct = 8 + (fi / totalFrames) * 85;
    if (fi % 10 === 0) {
      const step = fi < totalFrames * 0.25 ? 1 : fi < totalFrames * 0.75 ? 2 : 3;
      setProgress(pct, `frame ${fi}/${totalFrames}`, step);
      await sleep(0); /* yield to browser */
    }
  }

  setProgress(93, 'encoding video...', 3);
  recorder.stop();
  await new Promise(r => { recorder.onstop = r; });

  const videoBlob = new Blob(chunks, { type: mimeType });

  /* â”€â”€ AUDIO HANDLING â”€â”€ */
  if (replaceAudioFile) {
    setProgress(96, 'mixing audio...', 3);
    return await muxAudio(videoBlob, replaceAudioFile, duration);
  } else {
    /* Preserve original audio */
    setProgress(96, 'preserving audio...', 3);
    try {
      return await muxAudio(videoBlob, srcFile, duration, true);
    } catch(e) {
      return videoBlob; /* fallback: silent */
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FIND MOTION HOTSPOTS
   Returns up to ~8 strong-motion coordinates
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function findHotspots(luma, prev, W, H) {
  /* Grid-sample the frame for motion, keep strongest cells */
  const GRID = 10;
  const cw = Math.floor(W / GRID);
  const ch = Math.floor(H / GRID);
  const cells = [];

  for (let gy = 0; gy < GRID; gy++) {
    for (let gx = 0; gx < GRID; gx++) {
      let total = 0, count = 0;
      for (let py = gy * ch; py < (gy + 1) * ch && py < H; py++) {
        for (let px = gx * cw; px < (gx + 1) * cw && px < W; px++) {
          const i = py * W + px;
          total += Math.abs(luma[i] - prev[i]);
          count++;
        }
      }
      const avg = total / count;
      if (avg > 28) { /* HIGH threshold â€” only major movement */
        cells.push({ x: gx * cw + cw / 2, y: gy * ch + ch / 2, score: avg });
      }
    }
  }

  /* Sort by score descending, take top 6 */
  cells.sort((a, b) => b.score - a.score);
  return cells.slice(0, 6);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DRAW NODE GRAPH OVERLAY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawNodeGraph(ctx, nodes, W, H) {
  if (nodes.length < 2) return;

  ctx.save();

  /* â€” Draw connecting lines between ALL nodes â€” */
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i], b = nodes[j];
      const alpha = Math.min(a.life, b.life) * 0.75;
      const d = dist(a.x, a.y, b.x, b.y);
      /* Only draw lines within a reasonable range */
      if (d > W * 0.8) continue;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1.2;
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(220,240,255,0.8)';
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();
    }
  }

  /* â€” Draw node squares + labels â€” */
  for (const n of nodes) {
    const alpha = n.life;
    const sz = 8;

    ctx.save();
    ctx.globalAlpha = alpha;

    /* Outer square */
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5;
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'rgba(200,230,255,0.9)';
    ctx.strokeRect(n.x - sz, n.y - sz, sz * 2, sz * 2);

    /* Inner bright fill flash */
    ctx.fillStyle = 'rgba(220,240,255,0.12)';
    ctx.fillRect(n.x - sz + 1, n.y - sz + 1, sz * 2 - 2, sz * 2 - 2);

    /* Center dot */
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(n.x, n.y, 2, 0, Math.PI * 2);
    ctx.fill();

    /* Hex label */
    ctx.shadowBlur = 0;
    ctx.font = '9px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(200,230,255,0.85)';
    ctx.fillText(n.hexVal, n.x - sz, n.y - sz - 4);

    ctx.restore();
  }

  ctx.restore();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UTILITIES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getLuma(imgData, W, H) {
  const d = imgData.data;
  const luma = new Float32Array(W * H);
  for (let i = 0; i < W * H; i++) {
    const p = i * 4;
    luma[i] = 0.299 * d[p] + 0.587 * d[p+1] + 0.114 * d[p+2];
  }
  return luma;
}

function dist(ax, ay, bx, by) {
  const dx = ax - bx, dy = ay - by;
  return Math.sqrt(dx * dx + dy * dy);
}

function seekTo(vid, t) {
  return new Promise(res => {
    if (Math.abs(vid.currentTime - t) < 0.001) { res(); return; }
    vid.onseeked = () => { vid.onseeked = null; res(); };
    vid.currentTime = t;
  });
}

function getSupportedMime() {
  const types = [
    'video/webm;codecs=vp9',
    'video/webm;codecs=vp8',
    'video/webm',
  ];
  return types.find(t => MediaRecorder.isTypeSupported(t)) || 'video/webm';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AUDIO MUXING
   Combine processed video blob with an audio source
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function muxAudio(videoBlob, audioSource, maxDuration, isVideoSrc = false) {
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const actx = new AudioContext();

    const audioBuf = await actx.decodeAudioData(await audioSource.arrayBuffer());

    const sampleRate = audioBuf.sampleRate;
    const maxSamples = Math.floor(maxDuration * sampleRate);
    const srcLen = Math.min(audioBuf.length, maxSamples);
    const numCh = audioBuf.numberOfChannels;

    const trimmed = actx.createBuffer(numCh, srcLen, sampleRate);
    for (let c = 0; c < numCh; c++) {
      trimmed.copyToChannel(audioBuf.getChannelData(c).slice(0, srcLen), c);
    }

    /* Encode trimmed audio to WAV */
    const wavBlob = encodeWAV(trimmed);

    /* Build a combined blob-URL using HTML5 video element */
    /* We'll serve both blobs, then record the result */
    return await combineVideoAudio(videoBlob, wavBlob, maxDuration);
  } catch (e) {
    console.warn('Audio mux failed, returning silent video:', e);
    return videoBlob;
  }
}

async function combineVideoAudio(videoBlob, audioBlob, duration) {
  /* Create an invisible video element synced with an audio element,
     capture them on a canvas, record the result */
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const actx = new AudioContext();

  const vURL = URL.createObjectURL(videoBlob);
  const aURL = URL.createObjectURL(audioBlob);

  const v = document.createElement('video');
  v.src = vURL; v.muted = false; v.volume = 1;

  const a = document.createElement('audio');
  a.src = aURL;

  await new Promise(r => { v.onloadedmetadata = r; v.load(); });
  await seekTo(v, 0);

  const W = v.videoWidth, H = v.videoHeight;
  const canvas = document.createElement('canvas');
  canvas.width = W; canvas.height = H;
  const ctx2 = canvas.getContext('2d');

  /* Connect audio to media stream destination */
  const dest = actx.createMediaStreamDestination();
  const audioEl = actx.createMediaElementSource(a);
  audioEl.connect(dest);

  /* Combine canvas video + audio destination tracks */
  const canvasStream = canvas.captureStream(30);
  const combined = new MediaStream([
    ...canvasStream.getVideoTracks(),
    ...dest.stream.getAudioTracks()
  ]);

  const mimeType = getSupportedMime();
  const chunks2 = [];
  const rec2 = new MediaRecorder(combined, { mimeType, videoBitsPerSecond: 8_000_000 });
  rec2.ondataavailable = e => { if (e.data.size > 0) chunks2.push(e.data); };
  rec2.start(200);

  v.play(); a.play();
  await new Promise(r => setTimeout(r, (duration + 0.5) * 1000));

  v.pause(); a.pause();
  rec2.stop();
  await new Promise(r => { rec2.onstop = r; });

  return new Blob(chunks2, { type: mimeType });
}

/* Simple PCM â†’ WAV encoder */
function encodeWAV(buffer) {
  const numCh = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const numSamples = buffer.length;
  const bytesPerSample = 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numSamples * blockAlign;
  const bufSize = 44 + dataSize;
  const ab = new ArrayBuffer(bufSize);
  const view = new DataView(ab);
  let p = 0;
  const wr = (v, n) => { for (let i=0;i<n;i++,p++) view.setUint8(p, v & 0xff, true), v >>= 8; };
  const str = s => { for (let c of s) view.setUint8(p++, c.charCodeAt(0)); };
  str('RIFF'); wr(bufSize - 8, 4); str('WAVE');
  str('fmt '); wr(16,4); wr(1,2); wr(numCh,2); wr(sampleRate,4); wr(byteRate,4); wr(blockAlign,2); wr(16,2);
  str('data'); wr(dataSize,4);
  const interleaved = new Float32Array(numSamples * numCh);
  for (let c = 0; c < numCh; c++) {
    const ch = buffer.getChannelData(c);
    for (let i = 0; i < numSamples; i++) interleaved[i * numCh + c] = ch[i];
  }
  for (let i = 0; i < interleaved.length; i++) {
    const s = Math.max(-1, Math.min(1, interleaved[i]));
    const v = s < 0 ? s * 0x8000 : s * 0x7FFF;
    view.setInt16(p, v, true); p += 2;
  }
  return new Blob([ab], { type: 'audio/wav' });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESULT & DOWNLOAD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showResult(blob) {
  const url = URL.createObjectURL(blob);
  document.getElementById('resultVideo').src = url;
  document.getElementById('progressSection').classList.remove('show');
  document.getElementById('resultSection').classList.add('show');
  document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
  convertBtn.disabled = false;
}

function openDl() { document.getElementById('dlOverlay').classList.add('open'); }
function closeDl() { document.getElementById('dlOverlay').classList.remove('open'); }

function doDownload(fmt) {
  if (!resultBlob) return;
  closeDl();
  /* All formats use the same webm blob from MediaRecorder â€”
     we relabel the extension. MP4/MOV may not be natively writable
     from the browser; the blob is webm under the hood regardless of extension. */
  const ext = fmt;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(resultBlob);
  a.download = 'vfxai-output.' + ext;
  a.click();
}

function resetAll() {
  videoFile = null; audioFile = null; resultBlob = null;
  audioOn = false;
  videoInput.value = '';
  document.getElementById('audioInput').value = '';
  document.getElementById('audioName').style.display = 'none';
  document.getElementById('audioToggle').classList.remove('active');
  document.getElementById('audioExtra').classList.remove('show');
  uploadArea.classList.remove('has-file');
  fileChip.style.display = 'none';
  document.getElementById('progressSection').classList.remove('show');
  document.getElementById('resultSection').classList.remove('show');
  document.getElementById('resultVideo').src = '';
  convertBtn.disabled = true;
  window.scrollTo({ top: 0, behavior: 'smooth' });
}
</script>
</body>
</html>
